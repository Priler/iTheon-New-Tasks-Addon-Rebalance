-- stage 0: go to darkscape at night
-- stage 1: kill all mutants (one tag at a time)

-- stage 2: return to quest giver for reward

-- cached globals
local pairs = pairs
local ipairs = ipairs
local math_random = math.random
local math_ceil = math.ceil
local math_sqrt = math.sqrt
local alife_object = alife_object
local alife_create = alife_create
local alife_release = alife_release
local level_object_by_id = level.object_by_id
local time_global = time_global
local CreateTimeEvent = CreateTimeEvent
local RemoveTimeEvent = RemoveTimeEvent
local ResetTimeEvent = ResetTimeEvent

local state = {}
local marker_id = nil

-- ### Adaptive Difficulty

-- armor tier to spawn percentage (1.0 = 100% of enemies spawn)
local DIFFICULTY_TIERS = {
    low = 0.5,      -- basic gear: 50%
    medium = 0.75,  -- mid gear: 75%
    high = 1.0      -- endgame: 100%
}

-- use shared armor tier detection
function get_player_difficulty_tier()
    return nta_armor_tiers.get_armor_tier()
end

-- get spawn multiplier based on gear
function get_spawn_multiplier()
    local tier = get_player_difficulty_tier()
    return DIFFICULTY_TIERS[tier] or 1.0
end

function save_state(mdata)
    mdata.dead_night_task_data = state
    mdata.dead_night_marker_id = marker_id
end

function load_state(mdata)
    if mdata.dead_night_task_data then
        state = mdata.dead_night_task_data
    end
    if mdata.dead_night_marker_id then
        marker_id = mdata.dead_night_marker_id
    end
end

-- spawn marker at trigger location
function ensure_marker_exists()
    -- check if marker exists
    if marker_id then
        local se_obj = alife_object(marker_id)
        if se_obj then
            return marker_id
        end
    end
    
    -- spawn marker (invisible obj)
    local spawn_section = "level_changer"  -- invisible, won't interfere with gameplay
    local pos = dead_night_configs.spawn_trigger
    
    -- lvid/gvid from spawn configs
    local lvid = 139350  -- from position data
    local gvid = 1159    -- from position data
    
    local se_obj = alife_create(spawn_section, pos, lvid, gvid)
    if se_obj then
        marker_id = se_obj.id
        return marker_id
    end
    
    return nil
end

-- remove marker
function remove_marker()
    if marker_id then
        local se_obj = alife_object(marker_id)
        if se_obj then
            alife_release(se_obj)
        end
        marker_id = nil
    end
end

-- protection duration (seconds)
local PROTECTION_DURATION = 5

-- grant temp invulnerability
function protect_player()
    if not (db.actor and db.actor:alive()) then return end
    
    db.actor.invulnerable = true
    
    -- remove after delay
    CreateTimeEvent("dead_night", "remove_protection", PROTECTION_DURATION, function()
        if db.actor and db.actor:alive() then
            db.actor.invulnerable = false
        end
        return true  -- Remove this time event
    end)
end

task_status_functor.dead_night_task_status_functor = function(tsk, task_id)
    if not (db.actor and tsk) then return end
    local stage = tsk.stage
    
    if (stage == 0) then
        -- ensure marker exists
        ensure_marker_exists()
        
        if nta_utils.actor_on_level(nta_utils.levels.darkscape) and nta_utils.is_dark_night() then
            if nta_utils.actor_in_range(dead_night_configs.spawn_trigger, 12) then
                -- cleanup marker
                remove_marker()
                
                -- protect during spawn
                protect_player()
                
                spawn()
                level.add_pp_effector("fade_in.ppe", 200, false)
                tsk.stage = 1
            else
                spawn_sound()
            end
        end
    end
    
    if (stage == 1) then
        if not nta_utils.actor_on_level(nta_utils.levels.darkscape) then return 'fail' end
        if #state == 0 then
            tsk.stage = 2
        end
    end
end

-- spawn distance offset (meters)
local SPAWN_DISTANCE_OFFSET = 15

-- controller spawn delay (seconds)
local CONTROLLER_DELAY_MIN = 5
local CONTROLLER_DELAY_MAX = 10

function spawn()
    local actor_pos = db.actor:position()
    
    -- play scream sound
    nta_utils.spawn_sound_at_position([[new_tasks_addon\scream_1_shrike]], dead_night_configs.spawn_trigger)
    
    -- get spawn multiplier
    local spawn_multiplier = get_spawn_multiplier()
    
    -- separate regular from special enemies
    local regular_spawns = {}
    local special_spawns = {}
    local regular_count = 0
    
    for _, spawn_config in ipairs(dead_night_configs.spawn_configs) do
        -- get section
        local section = spawn_config.section_func()
        
        if section == "m_controller_normal" or section == "zombie_blind" then
            special_spawns[#special_spawns + 1] = { config = spawn_config, section = section }
        else
            regular_count = regular_count + 1
            regular_spawns[regular_count] = { config = spawn_config, section = section }
        end
    end
    
    -- apply difficulty to regular spawns only
    local num_regular_to_spawn = math_ceil(regular_count * spawn_multiplier)
    
    -- shuffle to randomize skipped spawns
    shuffle_table(regular_spawns)
    
    -- spawn regular enemies
    for i = 1, num_regular_to_spawn do
        local spawn_data = regular_spawns[i]
        if spawn_data then
            spawn_single_enemy(spawn_data.config, spawn_data.section, actor_pos)
        end
    end
    
    -- spawn special enemies
    for i = 1, #special_spawns do
        local spawn_data = special_spawns[i]
        if spawn_data.section == "m_controller_normal" then
            local delay = math_random(CONTROLLER_DELAY_MIN, CONTROLLER_DELAY_MAX)
            
            -- store in closure
            local config = spawn_data.config
            local section = spawn_data.section
            
            CreateTimeEvent("dead_night", "spawn_controller_" .. math_random(1000, 9999), delay, function()
                -- safety check
                if not (db.actor and db.actor:alive()) then
                    return true
                end
                if not nta_utils.actor_on_level(nta_utils.levels.darkscape) then
                    return true
                end
                
                -- spawn controller (no offset for AI pathing)
                local spawned_id = nta_utils.spawn_helper({
                    vector = config.vector,
                    lvid = config.lvid,
                    gvid = config.gvid,
                    section = section
                })
                
                if spawned_id then
                    state[#state + 1] = spawned_id
                    -- start aggro loop
                    start_controller_aggro(spawned_id)
                end
                return true
            end)
        else
            -- blind zombies spawn immediately
            spawn_single_enemy(spawn_data.config, spawn_data.section, actor_pos)
        end
    end
end

-- keep controller aggressive
function start_controller_aggro(controller_id)
    local aggro_event_id = "controller_aggro_" .. controller_id
    
    CreateTimeEvent("dead_night", aggro_event_id, 0.5, function()
        -- safety check
        if not (db.actor and db.actor:alive()) then
            return true  -- Stop aggro loop
        end
        
        -- stop if not on darkscape
        if not nta_utils.actor_on_level(nta_utils.levels.darkscape) then
            return true  -- Stop aggro loop
        end
        
        -- check if controller exists
        local se_obj = alife_object(controller_id)
        if not se_obj or not se_obj:alive() then
            return true  -- Controller dead, stop aggro loop
        end
        
        local monster = level_object_by_id(controller_id)
        if not monster then
            -- not loaded yet, retry later
            ResetTimeEvent("dead_night", aggro_event_id, 1.5)
            return false
        end
        
        -- hit controller to maintain aggro
        local h = hit()
        h.power = 0.0001  -- Near-zero damage
        h.impulse = 0
        h.draftsman = db.actor
        
        local actor_pos = db.actor:position()
        local monster_pos = monster:position()
        h.direction = vector():set(
            monster_pos.x - actor_pos.x,
            monster_pos.y - actor_pos.y,
            monster_pos.z - actor_pos.z
        )
        
        h.type = hit.wound
        monster:hit(h)
        
        -- continue loop every 1.5s
        ResetTimeEvent("dead_night", aggro_event_id, 1.5)
        return false  -- Keep event alive
    end)
end

-- shuffle table (fisher-yates)
local function shuffle_table(t)
    for i = #t, 2, -1 do
        local j = math_random(i)
        t[i], t[j] = t[j], t[i]
    end
end

-- spawn single enemy with offset



function spawn_single_enemy(spawn_config, section, actor_pos, extra_offset, make_aggressive)
    extra_offset = extra_offset or 0
    local total_offset = SPAWN_DISTANCE_OFFSET + extra_offset
    
    -- calc direction and offset
    local spawn_pos = spawn_config.vector
    local dir_x = spawn_pos.x - actor_pos.x
    local dir_z = spawn_pos.z - actor_pos.z
    local dist = math_sqrt(dir_x * dir_x + dir_z * dir_z)
    
    local spawned_id = nil
    
    if dist > 0.1 then
        -- normalize and apply offset
        local inv_dist = 1 / dist
        dir_x = dir_x * inv_dist
        dir_z = dir_z * inv_dist
        
        -- push position away from player
        local offset_pos = vector():set(
            spawn_pos.x + dir_x * total_offset,
            spawn_pos.y,
            spawn_pos.z + dir_z * total_offset
        )
        
        -- use offset position
        spawned_id = nta_utils.spawn_helper({
            vector = offset_pos,
            lvid = spawn_config.lvid,
            gvid = spawn_config.gvid,
            section = section
        })
    else
        -- fallback if player at spawn
        spawned_id = nta_utils.spawn_helper({
            vector = spawn_pos,
            lvid = spawn_config.lvid,
            gvid = spawn_config.gvid,
            section = section
        })
    end
    
    if spawned_id then
        state[#state + 1] = spawned_id
        
        -- make aggressive toward player
        if make_aggressive then
            -- delay for monster init
            CreateTimeEvent("dead_night", "aggro_" .. spawned_id, 0.5, function()
                -- safety check
                if not (db.actor and db.actor:alive()) then
                    return true
                end
                if not nta_utils.actor_on_level(nta_utils.levels.darkscape) then
                    return true
                end
                
                local monster = level_object_by_id(spawned_id)
                if monster then
                    -- tiny hit to trigger aggro
                    local h = hit()
                    h.power = 0.001  -- Minimal damage
                    h.impulse = 0
                    h.draftsman = db.actor
                    
                    -- calc direction
                    local actor_pos = db.actor:position()
                    local monster_pos = monster:position()
                    h.direction = vector():set(
                        monster_pos.x - actor_pos.x,
                        monster_pos.y - actor_pos.y,
                        monster_pos.z - actor_pos.z
                    )
                    
                    h.type = hit.wound
                    monster:hit(h)
                end
                return true
            end)
        end
    end
    
    return spawned_id
end

local iterations = 0
function spawn_sound()
    iterations = iterations + 1
    if iterations % 10 == 0 then
        nta_utils.spawn_sound_at_position([[new_tasks_addon\scream_1_shrike]], dead_night_configs.spawn_trigger)
        iterations = 0
    end
end

-- cache for current target
local cached_target_id = nil
local cached_target_valid_until = 0
local cached_marker_id = nil  -- Stage 0 marker never changes, cache permanently

task_functor.dead_night_task_target_functor = function(task_id, field, p, tsk)
    if not (db.actor and tsk) then return nil end
    local stage = tsk.stage
    
    if stage == 0 then
        -- marker never changes, cache it
        if cached_marker_id then
            return cached_marker_id
        end
        cached_marker_id = ensure_marker_exists()
        return cached_marker_id
        
    elseif stage == 1 then
        -- clear stage 0 cache
        cached_marker_id = nil
        
        if not nta_utils.actor_on_level(nta_utils.levels.darkscape) then return nil end
        
        -- use cached target if valid
        local current_time = time_global()
        if cached_target_id and current_time < cached_target_valid_until then
            local se_obj = alife_object(cached_target_id)
            if se_obj and se_obj:alive() then
                return cached_target_id
            end
        end
        
        -- find new target
        for _, id in ipairs(state) do
            local se_obj = alife_object(id)
            if se_obj and se_obj:alive() then
                cached_target_id = id
                cached_target_valid_until = current_time + 1000  -- Cache for 1 second
                return id
            end
        end
        cached_target_id = nil
        return nil
        
    elseif stage == 2 then
        return tsk.task_giver_id
    end
    
    return nil
end

xr_effects.dead_night_cleanup = function()
    -- stop controller aggro events
    for _, id in ipairs(state) do
        RemoveTimeEvent("dead_night", "controller_aggro_" .. id)
        RemoveTimeEvent("dead_night", "aggro_" .. id)
    end
    RemoveTimeEvent("dead_night", "remove_protection")
    
    state = {}
    iterations = 0
    cached_target_id = nil
    cached_target_valid_until = 0
    cached_marker_id = nil
    remove_marker()
end

function on_game_start()
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("monster_on_death_callback", monster_on_death_callback)
end

function monster_on_death_callback(monster)
    -- early exit if not active
    if not monster or #state == 0 then return end
    
    local id = monster:id()
    
    -- find and remove id
    for i = #state, 1, -1 do
        if state[i] == id then
            table.remove(state, i)
            return  -- Found and removed, exit early
        end
    end
end
